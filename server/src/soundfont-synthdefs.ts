/**
 * Generates SuperCollider SynthDefs for soundfont instruments with proper ADSR envelopes.
 * 
 * SuperDirt's default sample player doesn't support long attack/release envelopes
 * because samples stop when they reach their end. These custom synths:
 * 1. Loop the sample while the note is sustained
 * 2. Apply proper ADSR envelope
 * 3. Support all the standard SuperDirt parameters
 */

// Template for generating a soundfont instrument SynthDef
export function generateSoundfontSynthDef(
  instrumentName: string,
  numSampleChannels: number,
  numOutputChannels: number
): string {
  // SynthDef name matches the pattern SuperDirt expects
  const synthName = `strudel_${instrumentName}_${numSampleChannels}_${numOutputChannels}`;
  
  return `
// ${instrumentName} with ADSR envelope support
SynthDef("${synthName}", { |out, bufnum, sustain = 1, speed = 1, freq = 440, pan = 0,
                           attack = 0.001, decay = 0.1, sustainLevel = 1, release = 0.01,
                           begin = 0, end = 1, gain = 1, amp = 0.4|
  var sound, rate, phase, frames, env, totalTime;
  
  // Calculate playback rate (freq relative to middle C = MIDI 60)
  rate = speed * (freq / 60.midicps) * BufRateScale.ir(bufnum);
  frames = BufFrames.ir(bufnum);
  
  // Total envelope time
  totalTime = attack + decay + sustain + release;
  
  // ADSR envelope - gate stays open for sustain duration
  env = EnvGen.ar(
    Env.adsr(attack, decay, sustainLevel, release, 1, -4),
    gate: Trig.kr(1, sustain + attack + decay),  // Gate open for note duration
    doneAction: 2
  );
  
  // Loop through sample using Phasor for seamless looping
  phase = Phasor.ar(
    trig: 0,
    rate: rate * BufSampleRate.ir(bufnum) / SampleRate.ir,
    start: begin * frames,
    end: end * frames,
    resetPos: begin * frames
  );
  
  sound = BufRd.ar(${numSampleChannels}, bufnum, phase, loop: 1, interpolation: 4);
  
  // Apply envelope and gain
  sound = sound * env * amp * pow(gain, 4);
  
  Out.ar(out, DirtPan.ar(sound, ${numOutputChannels}, pan));
}, [\\ir, \\ir, \\ir, \\ir, \\ir, \\kr, \\ir, \\ir, \\ir, \\ir, \\ir, \\ir, \\kr, \\kr]).add;

"Added: ${synthName}".postln;
`;
}

/**
 * Generate SuperCollider code to register all soundfont synths
 * This should be run in SuperCollider after SuperDirt boots
 */
export function generateAllSoundfontSynthDefs(
  instrumentNames: string[],
  numOutputChannels: number = 2
): string {
  const header = `/*
  Strudel Soundfont SynthDefs
  Generated by nvim-strudel
  
  These SynthDefs provide proper ADSR envelope support for soundfont samples.
  Run this after SuperDirt is booted.
  
  Usage in Strudel:
    note("c4").s("gm_piano").attack(0.5).release(1)
    
  The server will automatically use the custom synth when ADSR params are present.
*/

(
var numChannels = ~dirt.numChannels;
`;

  const footer = `
"Strudel soundfont SynthDefs loaded: ${instrumentNames.length} instruments".postln;
)
`;

  // Generate synths for both mono and stereo samples
  const synthDefs = instrumentNames.map(name => {
    return [
      generateSoundfontSynthDef(name, 1, numOutputChannels),  // mono samples
      generateSoundfontSynthDef(name, 2, numOutputChannels),  // stereo samples
    ].join('\n');
  }).join('\n');

  return header + synthDefs + footer;
}

/**
 * Generate a simpler attack/release synth (no decay/sustain level)
 * This is more commonly needed and matches the Env.linen shape
 */
export function generateSimpleSoundfontSynthDef(
  instrumentName: string,
  numSampleChannels: number,
  numOutputChannels: number
): string {
  const synthName = `strudel_ar_${instrumentName}_${numSampleChannels}_${numOutputChannels}`;
  
  return `
// ${instrumentName} with attack/release envelope
SynthDef("${synthName}", { |out, bufnum, sustain = 1, speed = 1, freq = 440, pan = 0,
                           attack = 0.001, release = 0.01, begin = 0, end = 1,
                           gain = 1, amp = 0.4|
  var sound, rate, phase, frames, env, holdTime;
  
  rate = speed * (freq / 60.midicps) * BufRateScale.ir(bufnum);
  frames = BufFrames.ir(bufnum);
  
  // Hold time is sustain minus attack and release
  holdTime = max(0.001, sustain - attack - release);
  
  // Linen envelope: attack -> hold at 1 -> release
  env = EnvGen.ar(
    Env.linen(attack, holdTime, release, 1, \\sin),
    doneAction: 2
  );
  
  // Loop through sample
  phase = Phasor.ar(0, rate * BufSampleRate.ir(bufnum) / SampleRate.ir,
                    begin * frames, end * frames, begin * frames);
  
  sound = BufRd.ar(${numSampleChannels}, bufnum, phase, loop: 1, interpolation: 4);
  sound = sound * env * amp * pow(gain, 4);
  
  Out.ar(out, DirtPan.ar(sound, ${numOutputChannels}, pan));
}, [\\ir, \\ir, \\ir, \\ir, \\ir, \\kr, \\ir, \\ir, \\ir, \\ir, \\kr, \\kr]).add;

"Added: ${synthName}".postln;
`;
}

/**
 * Send OSC message to SuperCollider to evaluate code
 * This dynamically creates SynthDefs at runtime
 */
export function generateOscEvalMessage(scCode: string): { address: string; args: any[] } {
  return {
    address: '/strudel/eval',
    args: [{ type: 's', value: scCode }],
  };
}

/**
 * Generate the OSC handler code that should be added to SuperDirt startup
 * This allows the server to send SynthDef code to be evaluated
 */
export function generateSuperDirtOscHandler(): string {
  return `
// Strudel code evaluation handler
// Allows the nvim-strudel server to dynamically create SynthDefs
OSCdef(\\strudelEval, { |msg|
  var code = msg[1].asString;
  "Strudel: Evaluating code...".postln;
  code.interpret;
}, '/strudel/eval');

"Strudel OSC eval handler registered: /strudel/eval".postln;
`;
}
